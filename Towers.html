<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tower Defense</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <h1>Tower Defense</h1>
    <div class="game-container">
        <canvas id="gameCanvas"></canvas>
        <div class="ui-panel">
            <div>–î–µ–Ω—å–≥–∏: <span id="money">100</span></div>
            <div>–í–æ–ª–Ω–∞: <span id="wave">0</span></div>
            <div>–ñ–∏–∑–Ω–∏: <span id="lives">20</span></div>
            <button id="startWaveButton">–ù–∞—á–∞—Ç—å –≤–æ–ª–Ω—É</button>
            <div id="tower-selection">
                <h3>–ö—É–ø–∏—Ç—å –±–∞—à–Ω—é:</h3>
                <button class="tower-button" data-type="basic" data-cost="50">–ü—Ä–æ—Å—Ç–∞—è –ë–∞—à–Ω—è (50)</button>
                <button class="tower-button" data-type="splash" data-cost="100">–û–±–ª–∞—Å—Ç—å (100)</button>
                <button class="tower-button" data-type="sniper" data-cost="120">–°–Ω–∞–π–ø–µ—Ä (120)</button>
                <button id="upgradeTowerButton" disabled>–£–ª—É—á—à–∏—Ç—å –±–∞—à–Ω—é (–°—Ç–æ–∏–º–æ—Å—Ç—å: <span id="upgradeCost">50</span>)</button>
                <!-- –°—é–¥–∞ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏ –¥–ª—è –¥—Ä—É–≥–∏—Ö —Ç–∏–ø–æ–≤ –±–∞—à–µ–Ω -->
            </div>
            <div id="game-status"></div>
        </div>
    </div>
    <script src="script.js"></script>
</body>
<style>
body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
    margin: 0;
    background-color: #f0f0f0;
}

h1 {
    margin-top: 10px;
    margin-bottom: 10px;
}

.game-container {
    display: flex;
    margin-top: 10px;
    border: 2px solid #333;
    box-shadow: 0 0 10px rgba(0,0,0,0.2);
}

#gameCanvas {
    border: 1px solid black;
    background-color: #e0ffe0; /* –°–≤–µ—Ç–ª–æ-–∑–µ–ª–µ–Ω—ã–π —Ñ–æ–Ω –¥–ª—è –ø–æ–ª—è */
}

.ui-panel {
    width: 220px;
    padding: 15px;
    background-color: #f8f9fa;
    border-left: 2px solid #333;
    display: flex;
    flex-direction: column;
    gap: 12px;
}

.ui-panel div, .ui-panel h3 {
    font-size: 16px;
}

.ui-panel h3 {
    margin-top: 10px;
    margin-bottom: 5px;
}

button {
    padding: 10px 15px;
    font-size: 16px;
    cursor: pointer;
    background-color: #28a745;
    color: white;
    border: none;
    border-radius: 5px;
    transition: background-color 0.2s;
}

button:hover {
    background-color: #7b961c;
}

button:disabled {
    background-color: #6c757d;
    cursor: not-allowed;
}

#tower-selection button {
    width: 100%;
    margin-top: 8px;
    background-color: #007bff;
}

#tower-selection button:hover {
    background-color: #0056b3;
}

#game-status {
    margin-top: auto; /* –ü—Ä–∏–∂–∏–º–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∫ –Ω–∏–∑—É –ø–∞–Ω–µ–ª–∏ */
    font-weight: bold;
    color: red;
}

#upgradeTowerButton {
    width: 100%;
    margin-top: 8px;
    background-color: #8e44ad; /* –§–∏–æ–ª–µ—Ç–æ–≤—ã–π —Ü–≤–µ—Ç */
}

#upgradeTowerButton:hover {
    background-color: #732d91;
}
</style>
<script>

// script.js
document.addEventListener('DOMContentLoaded', () => {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // UI Elements
    const moneyDisplay = document.getElementById('money');
    const waveDisplay = document.getElementById('wave');
    const livesDisplay = document.getElementById('lives');
    const startWaveButton = document.getElementById('startWaveButton');
    const towerButtons = document.querySelectorAll('.tower-button');
    const gameStatusDisplay = document.getElementById('game-status');
    const towersPlacedDisplay = document.createElement('div');

    // Game constants
    const TILE_SIZE = 40;
    canvas.width = TILE_SIZE * 20; // 800px
    canvas.height = TILE_SIZE * 15; // 600px
    const MAX_TOWERS = 12;

    // Game state
    let money = 250;
    let lives = 30;
    let currentWave = 0;
    let enemies = [];
    let towers = [];
    let projectiles = [];
    let visualEffects = []; // –î–ª—è –≤–∑—Ä—ã–≤–æ–≤, —Ç–µ–ª–µ–ø–æ—Ä—Ç–æ–≤ –∏ —Ç.–¥.
    let placingTower = null; // { type: 'basic', cost: 50, range: X, splashRadius: Y (optional) }
    let waveInProgress = false;
    let gameIsOver = false;
    let towersPlacedCount = 0;
    let mouseGridPos = { x: -1, y: -1 }; // –î–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–π –±–∞—à–Ω–∏
    //–£–ª—É—á—à–µ–Ω–∏–µ –±–∞—à–µ–Ω 
    let selectedTower = null;
    let upgradeCost = 25;

    // –ò–≥—Ä–æ–≤–æ–π –ø—É—Ç—å (–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã —Ü–µ–Ω—Ç—Ä–∞ –∫–ª–µ—Ç–æ–∫)
    const path = [
        { x: 0 * TILE_SIZE + TILE_SIZE / 2, y: 7 * TILE_SIZE + TILE_SIZE / 2 },
        { x: 5 * TILE_SIZE + TILE_SIZE / 2, y: 7 * TILE_SIZE + TILE_SIZE / 2 },
        { x: 5 * TILE_SIZE + TILE_SIZE / 2, y: 3 * TILE_SIZE + TILE_SIZE / 2 },
        { x: 12 * TILE_SIZE + TILE_SIZE / 2, y: 3 * TILE_SIZE + TILE_SIZE / 2 },
        { x: 12 * TILE_SIZE + TILE_SIZE / 2, y: 10 * TILE_SIZE + TILE_SIZE / 2 },
        { x: 19 * TILE_SIZE + TILE_SIZE / 2, y: 10 * TILE_SIZE + TILE_SIZE / 2 },
        { x: canvas.width + TILE_SIZE, y: 10 * TILE_SIZE + TILE_SIZE / 2 } // –¢–æ—á–∫–∞ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º –¥–ª—è –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø—É—Ç–∏
    ];

    // --- –ö–ª–∞—Å—Å—ã ---

    class GameObject {
        constructor(x, y, width, height, color) {
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.color = color;
            this.id = Math.random().toString(36).substr(2, 9); // –£–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        }

        draw(context) {
            context.fillStyle = this.color;
            context.fillRect(this.x - this.width / 2, this.y - this.height / 2, this.width, this.height);
        }

        // –ú–µ—Ç–æ–¥ update –±—É–¥–µ—Ç —É –Ω–∞—Å–ª–µ–¥–Ω–∏–∫–æ–≤
    }

    class Tower extends GameObject {
        constructor(x, y, type, cost, range, fireRate, projectileDamage, projectileSpeed, color = 'blue', splashRadius = 0) {
            super(x, y, TILE_SIZE * 0.8, TILE_SIZE * 0.8, color);
            this.type = type;
            this.cost = cost;
            this.range = range;
            this.fireRate = fireRate; // –í—ã—Å—Ç—Ä–µ–ª–æ–≤ –≤ —Å–µ–∫—É–Ω–¥—É
            this.projectileDamage = projectileDamage;
            this.projectileSpeed = projectileSpeed;
            this.lastShotTime = 0;
            this.target = null; // –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–±—ä–µ–∫—Ç –≤—Ä–∞–≥–∞
            this.splashRadius = splashRadius;
            this.isHovered = false;
        }

        draw(context) {
            super.draw(context);
            if (this.isHovered || (placingTower && this.x === mouseGridPos.x && this.y === mouseGridPos.y)) {
                context.beginPath();
                context.arc(this.x, this.y, this.range, 0, Math.PI * 2);
                context.strokeStyle = 'rgba(0, 0, 255, 0.3)';
                context.lineWidth = 2;
                context.stroke();
                context.lineWidth = 1;

                if (this.splashRadius > 0) {
                    context.beginPath();
                    context.arc(this.x, this.y, this.splashRadius, 0, Math.PI * 2);
                    context.strokeStyle = 'rgba(255, 165, 0, 0.3)';
                    context.stroke();
                }
            }
            this.isHovered = false;
        }

        findTarget(activeEnemies) {
            this.target = null;
            let closestDistanceSq = this.range * this.range;
            for (const enemy of activeEnemies) {
                // –ù–µ —Å—Ç—Ä–µ–ª—è–µ–º –ø–æ —É–∂–µ –º–µ—Ä—Ç–≤—ã–º (—Ö–æ—Ç—è –∏—Ö –¥–æ–ª–∂–Ω—ã –±—ã—Å—Ç—Ä–æ —É–¥–∞–ª—è—Ç—å)
                if (enemy.health <= 0) continue;

                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distanceSq = dx * dx + dy * dy;
                if (distanceSq < closestDistanceSq) {
                    closestDistanceSq = distanceSq;
                    this.target = enemy;
                }
            }
        }

        shoot(currentTime) {
            if (this.target && this.target.health > 0 && currentTime - this.lastShotTime > 1000 / this.fireRate) {
                projectiles.push(new Projectile(this.x, this.y, this.target, this.projectileDamage, this.projectileSpeed, this.splashRadius, this.type === 'splash' ? 'orange' : 'yellow'));
                this.lastShotTime = currentTime;
            }
        }

        update(currentTime, activeEnemies) {
            this.findTarget(activeEnemies);
            this.shoot(currentTime);
        }
    }

    class Enemy extends GameObject {
        constructor(x, y, speed, health, reward, type = 'normal', color = 'red', sizeFactor = 0.6) {
            super(x, y, TILE_SIZE * sizeFactor, TILE_SIZE * sizeFactor, color);
            this.speed = speed;
            this.currentSpeed = speed; // –î–ª—è —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
            this.health = health;
            this.maxHealth = health;
            this.reward = reward;
            this.pathIndex = 0;
            this.type = type;

            this.isTeleporting = false;
            this.teleportCooldown = 3000 + Math.random() * 2000; // –º—Å, —Å —Ä–∞–∑–±—Ä–æ—Å–æ–º
            this.lastTeleportTime = Date.now();
            this.teleportDistanceFactor = 2.5; // –Ω–∞ —Å–∫–æ–ª—å–∫–æ TILE_SIZE —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å—Å—è
        }

        draw(context) {
            super.draw(context);
            // –ü–æ–ª–æ—Å–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
            const barWidth = this.width;
            const barHeight = 5;
            context.fillStyle = '#555';
            context.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 3, barWidth, barHeight);
            const healthPercentage = this.health / this.maxHealth;
            context.fillStyle = healthPercentage > 0.6 ? 'green' : healthPercentage > 0.3 ? 'orange' : 'darkred';
            const hpWidth = barWidth * healthPercentage;
            context.fillRect(this.x - barWidth / 2, this.y - this.height / 2 - barHeight - 3, hpWidth > 0 ? hpWidth : 0, barHeight);

            if (this.type === 'boss') {
                context.fillStyle = 'gold';
                context.font = `${this.height * 0.8}px Arial`;
                context.textAlign = 'center';
                context.fillText('üëë', this.x, this.y - this.height / 2 - barHeight - 5);
            }
        }

        move() {
            if (this.pathIndex >= path.length) return; // –£–∂–µ –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ –≤–∏–¥–∏–º–æ–≥–æ –ø—É—Ç–∏

            if (this.type === 'teleporter' && !this.isTeleporting && Date.now() - this.lastTeleportTime > this.teleportCooldown) {
                this.attemptTeleport();
            }

            const targetPoint = path[this.pathIndex];
            const dx = targetPoint.x - this.x;
            const dy = targetPoint.y - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < this.currentSpeed) {
                this.x = targetPoint.x;
                this.y = targetPoint.y;
                this.pathIndex++;
            } else {
                this.x += (dx / distance) * this.currentSpeed;
                this.y += (dy / distance) * this.currentSpeed;
            }
        }

        attemptTeleport() {
            if (this.pathIndex >= path.length - 2) return; // –ù–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º—Å—è —É —Å–∞–º–æ–≥–æ –≤—ã—Ö–æ–¥–∞

            this.isTeleporting = true;
            this.lastTeleportTime = Date.now();
            const oldX = this.x;
            const oldY = this.y;

            let distanceToTeleport = TILE_SIZE * this.teleportDistanceFactor; // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞—Ü–∏–∏
            let tempPathIndex = this.pathIndex; // –í—Ä–µ–º–µ–Ω–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø—É—Ç–∏
            let currentPos = { x: this.x, y: this.y }; // –¢–µ–∫—É—â–∏–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã

            while (distanceToTeleport > 0 && tempPathIndex < path.length -1) {
                const nextNode = path[tempPathIndex]; // –°–ª–µ–¥—É—é—â–∞—è —Ç–æ—á–∫–∞ –Ω–∞ –ø—É—Ç–∏
                const dxNode = nextNode.x - currentPos.x;
                const dyNode = nextNode.y - currentPos.y;
                const distToNextNode = Math.sqrt(dxNode*dxNode + dyNode*dyNode); // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ —Å–ª–µ–¥—É—é—â–µ–π —Ç–æ—á–∫–∏

                if (distanceToTeleport >= distToNextNode) {
                    distanceToTeleport -= distToNextNode;
                    currentPos.x = nextNode.x;
                    currentPos.y = nextNode.y;
                    tempPathIndex++;
                } else {
                    const ratio = distanceToTeleport / distToNextNode;
                    currentPos.x += dxNode * ratio;
                    currentPos.y += dyNode * ratio;
                    distanceToTeleport = 0; // –ó–∞–≤–µ—Ä—à–∞–µ–º
                }
            }
            this.x = currentPos.x;
            this.y = currentPos.y;
            this.pathIndex = tempPathIndex; // –û–±–Ω–æ–≤–ª—è–µ–º –∏–Ω–¥–µ–∫—Å –ø—É—Ç–∏

            visualEffects.push(new VisualEffect(oldX, oldY, TILE_SIZE * 0.7, 'rgba(128,0,128,0.7)', 200, 'puff'));
            visualEffects.push(new VisualEffect(this.x, this.y, TILE_SIZE * 0.9, 'rgba(128,0,128,0.7)', 300, 'puff'));
            setTimeout(() => { this.isTeleporting = false; }, 500); // –ö–æ—Ä–æ—Ç–∫–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –ø–æ—Å–ª–µ —Ç–µ–ª–µ–ø–æ—Ä—Ç–∞
        }


        takeDamage(amount) {
            this.health -= amount;
            if (this.health <= 0) {
                this.health = 0; // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –∑–¥–æ—Ä–æ–≤—å–µ –Ω–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ
                money += this.reward;
                updateUIDisplay();
                return true; // –í—Ä–∞–≥ —É–±–∏—Ç
            }
            return false; // –í—Ä–∞–≥ –∂–∏–≤
        }

        update() {
            this.move();
            // –ü—Ä–æ–≤–µ—Ä–∫–∞, –¥–æ—Å—Ç–∏–≥ –ª–∏ –≤—Ä–∞–≥ –∫–æ–Ω—Ü–∞ (–ø–æ—Å–ª–µ–¥–Ω–µ–π —Ç–æ—á–∫–∏ –º–∞—Å—Å–∏–≤–∞ path, –∫–æ—Ç–æ—Ä–∞—è –∑–∞ —ç–∫—Ä–∞–Ω–æ–º)
            if (this.pathIndex >= path.length -1 && (this.x >= path[path.length-1].x -this.currentSpeed || this.x > canvas.width)) {
                lives--;
                updateUIDisplay();
                if (lives <= 0 && !gameIsOver) {
                    gameOver();
                }
                return true; // –í—Ä–∞–≥ –¥–æ—Å—Ç–∏–≥ –±–∞–∑—ã –∏ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–¥–∞–ª–µ–Ω
            }
            return false; // –í—Ä–∞–≥ –≤—Å–µ –µ—â–µ –Ω–∞ –ø—É—Ç–∏
        }
    }

    class Projectile extends GameObject {
        constructor(x, y, target, damage, speed, splashRadius = 0, color = 'yellow') {
            super(x, y, TILE_SIZE * (splashRadius > 0 ? 0.3 : 0.2), TILE_SIZE * (splashRadius > 0 ? 0.3 : 0.2), color);
            this.target = target; // –°—Å—ã–ª–∫–∞ –Ω–∞ –æ–±—ä–µ–∫—Ç –≤—Ä–∞–≥–∞
            this.damage = damage;
            this.speed = speed;
            this.splashRadius = splashRadius;
            this.targetLastPos = { x: target.x, y: target.y }; // –ù–∞ —Å–ª—É—á–∞–π –µ—Å–ª–∏ —Ü–µ–ª—å —É–º—Ä–µ—Ç –¥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è
        }

        update(activeEnemies) { // –ü–µ—Ä–µ–¥–∞–µ–º activeEnemies –¥–ª—è —Å–ø–ª–µ—à-—É—Ä–æ–Ω–∞
            let currentTargetX, currentTargetY;
            let targetIsAlive = this.target && this.target.health > 0;

            if (targetIsAlive) {
                this.targetLastPos = { x: this.target.x, y: this.target.y };
                currentTargetX = this.target.x;
                currentTargetY = this.target.y;
            } else {
                // –¶–µ–ª—å –º–µ—Ä—Ç–≤–∞ –∏–ª–∏ –ø–æ—Ç–µ—Ä—è–Ω–∞, –ª–µ—Ç–∏–º –≤ –ø–æ—Å–ª–µ–¥–Ω—é—é –∏–∑–≤–µ—Å—Ç–Ω—É—é –ø–æ–∑–∏—Ü–∏—é
                currentTargetX = this.targetLastPos.x;
                currentTargetY = this.targetLastPos.y;
            }

            const dx = currentTargetX - this.x;
            const dy = currentTargetY - this.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            const hitDistance = this.speed + (targetIsAlive ? this.target.width / 2 : 0);

            if (distance < hitDistance) {
                // –ü–æ–ø–∞–¥–∞–Ω–∏–µ
                if (targetIsAlive) {
                    this.target.takeDamage(this.damage);
                }
                if (this.splashRadius > 0) {
                    this.applySplashDamage(activeEnemies);
                }
                return true; // –°–Ω–∞—Ä—è–¥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —É–¥–∞–ª–µ–Ω
            } else {
                this.x += (dx / distance) * this.speed;
                this.y += (dy / distance) * this.speed;
            }
            return false; // –°–Ω–∞—Ä—è–¥ –≤ –ø–æ–ª–µ—Ç–µ
        }

        applySplashDamage(activeEnemies) {
            visualEffects.push(new VisualEffect(this.x, this.y, this.splashRadius * 2, 'rgba(255,165,0,0.5)', 250, 'explosion'));
            activeEnemies.forEach(enemy => {
                if (enemy.health <= 0 || enemy === this.target) return; // –ù–µ –±—å–µ–º —É–∂–µ –º–µ—Ä—Ç–≤—ã—Ö –∏–ª–∏ –æ—Å–Ω–æ–≤–Ω—É—é —Ü–µ–ª—å (–µ–µ —É–∂–µ —É–¥–∞—Ä–∏–ª–∏)

                const dx = enemy.x - this.x;
                const dy = enemy.y - this.y;
                const distanceSq = dx * dx + dy * dy;
                if (distanceSq < this.splashRadius * this.splashRadius) {
                    enemy.takeDamage(this.damage * 0.6); // –£—Ä–æ–Ω –ø–æ –æ–±–ª–∞—Å—Ç–∏, –Ω–∞–ø—Ä–∏–º–µ—Ä, 60% –æ—Ç –æ—Å–Ω–æ–≤–Ω–æ–≥–æ
                }
            });
        }
    }

    class VisualEffect extends GameObject {
        constructor(x, y, size, color, duration, type = 'explosion') {
            super(x, y, size, size, color); // width/height –∑–¥–µ—Å—å —É—Å–ª–æ–≤–Ω—ã
            this.initialSize = size;
            this.duration = duration;
            this.createdAt = Date.now();
            this.type = type;
        }

        draw(context) {
            const elapsed = Date.now() - this.createdAt;
            const progress = Math.min(elapsed / this.duration, 1);

            context.globalAlpha = 1 - progress;
            if (this.type === 'explosion') {
                context.beginPath();
                context.arc(this.x, this.y, this.initialSize * progress * 0.5, 0, Math.PI * 2); // –£–º–µ–Ω—å—à–∏–ª —Ä–∞–¥–∏—É—Å –ø—Ä–æ–≥—Ä–µ—Å—Å–∞
                context.fillStyle = this.color;
                context.fill();
            } else if (this.type === 'puff') {
                 context.beginPath();
                 context.arc(this.x, this.y, this.initialSize * (0.3 + progress * 0.7), 0, Math.PI * 2);
                 context.fillStyle = this.color;
                 context.fill();
            }
            context.globalAlpha = 1;
        }

        update() {
            return Date.now() - this.createdAt > this.duration; // True –µ—Å–ª–∏ —ç—Ñ—Ñ–µ–∫—Ç –∑–∞–∫–æ–Ω—á–∏–ª—Å—è
        }
    }

    // --- –§—É–Ω–∫—Ü–∏–∏ –∏–≥—Ä—ã ---

    function updateUIDisplay() {
        moneyDisplay.textContent = money;
        waveDisplay.textContent = currentWave;
        livesDisplay.textContent = lives;
        towersPlacedDisplay.textContent = `–ë–∞—à–Ω–∏: ${towersPlacedCount}/${MAX_TOWERS}`;
        //—É–ª—É—á—â–µ–Ω–∏–µ –±–∞—à–µ–Ω
        document.getElementById('upgradeCost').textContent = upgradeCost;
    }

    function drawPath() {
        ctx.strokeStyle = '#bababa'; // –°–≤–µ—Ç–ª–µ–µ
        ctx.lineWidth = TILE_SIZE * 0.85;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.beginPath();
        if (path.length > 0) {
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length - 1; i++) { // -1 —á—Ç–æ–±—ã –Ω–µ —Ä–∏—Å–æ–≤–∞—Ç—å –¥–æ –∫–æ–Ω–µ—á–Ω–æ–π —Ç–æ—á–∫–∏ –∑–∞ —ç–∫—Ä–∞–Ω–æ–º
                ctx.lineTo(path[i].x, path[i].y);
            }
        }
        ctx.stroke();
        ctx.lineWidth = 1;
        ctx.lineCap = "butt";
        ctx.lineJoin = "miter";
    }

    function drawGrid() {
        ctx.strokeStyle = '#e0e0e0';
        ctx.lineWidth = 0.5;
        for (let x = 0; x <= canvas.width; x += TILE_SIZE) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
        for (let y = 0; y <= canvas.height; y += TILE_SIZE) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }
        ctx.lineWidth = 1;
    }

    let waveEnemiesToSpawn = 0;
    let spawnIntervalId = null;
    let spawnCounter = 0;

    function spawnEnemyLogic() {
        const startPoint = path[0];
        let baseHealth = 50 + currentWave * 20;
        let baseSpeed = 1 + currentWave * 0.04;
        let baseReward = 8 + Math.floor(currentWave / 2);

        let enemyType = 'normal';
        let health = baseHealth;
        let speed = baseSpeed;
        let reward = baseReward;
        let color = '#c0392b'; // –ö—Ä–∞—Å–Ω—ã–π
        let sizeFactor = 0.6;

        // –ë–æ—Å—Å –Ω–∞ –∫–∞–∂–¥–æ–π 10-–π –≤–æ–ª–Ω–µ
        if (currentWave > 0 && currentWave % 10 === 0 && spawnCounter === Math.floor(waveEnemiesToSpawn / 2) && !enemies.some(e => e.type === 'boss')) {
            enemyType = 'boss';
            health = baseHealth * 15 + currentWave * 50;
            speed = baseSpeed * 0.35;
            reward = baseReward * 15;
            color = '#2c3e50'; // –¢–µ–º–Ω–æ-—Å–∏–Ω–∏–π/—á–µ—Ä–Ω—ã–π
            sizeFactor = 0.95;
            enemies.push(new Enemy(startPoint.x, startPoint.y, speed, health, reward, enemyType, color, sizeFactor));
            return; // –°–ø–∞–≤–Ω–∏–º —Ç–æ–ª—å–∫–æ –±–æ—Å—Å–∞ –≤ —ç—Ç–æ—Ç –º–æ–º–µ–Ω—Ç
        }

        // –†–∞–∑–Ω–æ–æ–±—Ä–∞–∑–∏–µ –æ–±—ã—á–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
        const randomFactor = Math.random();
        if (currentWave > 1 && randomFactor < 0.30) {
            enemyType = 'fast';
            health *= 0.55;
            speed *= 1.9;
            reward = Math.ceil(reward * 1.1);
            color = '#e74c3c'; // –Ø—Ä–∫–æ-–∫—Ä–∞—Å–Ω—ã–π
            sizeFactor = 0.45;
        } else if (currentWave > 3 && randomFactor < 0.55) { // (0.30 + 0.25)
            enemyType = 'tank';
            health *= 2.8;
            speed *= 0.55;
            reward = Math.ceil(reward * 1.3);
            color = '#7f8c8d'; // –°–µ—Ä—ã–π
            sizeFactor = 0.75;
        } else if (currentWave > 5 && randomFactor < 0.65) { // (0.55 + 0.10)
            enemyType = 'teleporter';
            health *= 0.9;
            speed *= 1.05;
            reward = Math.ceil(reward * 1.5);
            color = '#8e44ad'; // –§–∏–æ–ª–µ—Ç–æ–≤—ã–π
            sizeFactor = 0.55;
        }

        enemies.push(new Enemy(startPoint.x, startPoint.y, speed, health, reward, enemyType, color, sizeFactor));
    }

    function startNewWave() {
        if (waveInProgress || gameIsOver) return;
        waveInProgress = true;
        currentWave++;
        waveEnemiesToSpawn = 7 + currentWave * 3;
        if (currentWave > 0 && currentWave % 10 === 0) {
            waveEnemiesToSpawn = Math.max(1, Math.floor(waveEnemiesToSpawn * 0.6)); // –ú–µ–Ω—å—à–µ –æ–±—ã—á–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤ + 1 –±–æ—Å—Å
        }
        spawnCounter = 0;
        updateUIDisplay();
        startWaveButton.disabled = true;
        gameStatusDisplay.textContent = `–í–æ–ª–Ω–∞ ${currentWave} –Ω–∞—á–∞–ª–∞—Å—å!`;

        spawnIntervalId = setInterval(() => {
            if (spawnCounter < waveEnemiesToSpawn) {
                spawnEnemyLogic();
                spawnCounter++;
            } else {
                clearInterval(spawnIntervalId);
                spawnIntervalId = null;
                // –í–æ–ª–Ω–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è, –ø–æ–∫–∞ –µ—Å—Ç—å –≤—Ä–∞–≥–∏ –∏–ª–∏ –ø–æ–∫–∞ –Ω–µ –≤—Å–µ –æ—Ç—Å–ø–∞–≤–Ω–∏–ª–∏—Å—å
            }
        }, 1300 - Math.min(1000, currentWave * 30));
    }

    canvas.addEventListener('mousemove', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        mouseGridPos.x = Math.floor(x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
        mouseGridPos.y = Math.floor(y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;

        towers.forEach(tower => {
            const distSq = (mouseGridPos.x - tower.x)*(mouseGridPos.x - tower.x) + (mouseGridPos.y - tower.y)*(mouseGridPos.y - tower.y);
            tower.isHovered = distSq < (TILE_SIZE * 0.5) * (TILE_SIZE * 0.5);
        });
    });

    function isCellOnPath(gridX, gridY) {
        const checkRadius = TILE_SIZE * 0.55; // –ù–µ–º–Ω–æ–≥–æ –±–æ–ª—å—à–µ –ø–æ–ª–æ–≤–∏–Ω—ã –∫–ª–µ—Ç–∫–∏
        for (let i = 0; i < path.length - 1; i++) {
            const p1 = path[i];
            const p2 = path[i+1];
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –æ—Ç —Ç–æ—á–∫–∏ (gridX, gridY) –¥–æ –æ—Ç—Ä–µ–∑–∫–∞ (p1,p2)
            const lenSq = (p1.x-p2.x)**2 + (p1.y-p2.y)**2;
            if (lenSq === 0) { // –¢–æ—á–∫–∏ —Å–æ–≤–ø–∞–¥–∞—é—Ç
                if ((gridX-p1.x)**2 + (gridY-p1.y)**2 < checkRadius**2) return true;
                continue;
            }
            let t = ((gridX - p1.x) * (p2.x - p1.x) + (gridY - p1.y) * (p2.y - p1.y)) / lenSq;
            t = Math.max(0, Math.min(1, t));
            const closestX = p1.x + t * (p2.x - p1.x);
            const closestY = p1.y + t * (p2.y - p1.y);
            if ((gridX-closestX)**2 + (gridY-closestY)**2 < checkRadius**2) return true;
        }
        return false;
    }

    function isCellBuildable(gridX, gridY) {
        // 1. –ù–µ –≤—ã—Ö–æ–¥–∏—Ç –ª–∏ –∑–∞ –ø—Ä–µ–¥–µ–ª—ã –ø–æ–ª—è (—É–∂–µ —É—á—Ç–µ–Ω–æ –º—ã—à—å—é)
        // 2. –ù–µ –Ω–∞ –ø—É—Ç–∏ –ª–∏ –±–∞—à–Ω—è
        if (isCellOnPath(gridX, gridY)) return false;

        // 3. –ù–µ —Å–ª–∏—à–∫–æ–º –ª–∏ –¥–∞–ª–µ–∫–æ –æ—Ç –ø—É—Ç–∏ (–ø—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å–µ–¥–Ω–∏—Ö –∫–ª–µ—Ç–æ–∫ —Å –ø—É—Ç–µ–º)
        let nearPath = false;
        const buildDistance = TILE_SIZE * 2.5; // –ú–∞–∫—Å. —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç –ø—É—Ç–∏ –¥–ª—è —Å—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–∞
        for (const p of path) {
            if (Math.sqrt((gridX - p.x)**2 + (gridY - p.y)**2) < buildDistance) {
                nearPath = true;
                break;
            }
        }
        if (!nearPath) return false;

        // 4. –ù–µ—Ç –ª–∏ —É–∂–µ –±–∞—à–Ω–∏ –Ω–∞ —ç—Ç–æ–º –º–µ—Å—Ç–µ
        for (const tower of towers) {
            if (tower.x === gridX && tower.y === gridY) return false;
        }
        return true;
    }

    function handleTowerPlacement(event) {
        if (!placingTower || gameIsOver) return;

        const gridX = mouseGridPos.x;
        const gridY = mouseGridPos.y;

        if (towersPlacedCount >= MAX_TOWERS) {
            gameStatusDisplay.textContent = `–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –±–∞—à–µ–Ω (${MAX_TOWERS})!`;
            placingTower = null; // –°–±—Ä–æ—Å–∏—Ç—å –≤—ã–±–æ—Ä, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∑–∞–≤–∏—Å—à–µ–≥–æ –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä–∞
            setTimeout(() => gameStatusDisplay.textContent = "", 2000);
            return;
        }

        if (!isCellBuildable(gridX, gridY)) {
            gameStatusDisplay.textContent = "–ó–¥–µ—Å—å –Ω–µ–ª—å–∑—è —Å—Ç—Ä–æ–∏—Ç—å!";
             setTimeout(() => gameStatusDisplay.textContent = "", 2000);
            return;
        }

        if (money >= placingTower.cost) {
            money -= placingTower.cost;
            let newTower;
            // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –±–∞—à–µ–Ω: x, y, type, cost, range, fireRate, damage, projSpeed, color, splashRadius
            switch (placingTower.type) {
                case 'basic':
                    newTower = new Tower(gridX, gridY, 'basic', 100, TILE_SIZE * 3.2, 1.6, 25, 7, '#3498db');
                    break;
                case 'sniper':
                    newTower = new Tower(gridX, gridY, 'sniper', 120, TILE_SIZE * 6.0, 0.45, 110, 10, '#27ae60');
                    break;
                case 'splash':
                    newTower = new Tower(gridX, gridY, 'splash', 150, TILE_SIZE * 2.7, 1.1, 35, 6, '#e67e22', TILE_SIZE * 1.4);
                    break;
            }
            towers.push(newTower);
            towersPlacedCount++;
            updateUIDisplay();
            gameStatusDisplay.textContent = `–ë–∞—à–Ω—è ${placingTower.type} –ø–æ—Å—Ç—Ä–æ–µ–Ω–∞!`;
        } else {
            gameStatusDisplay.textContent = "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–µ–Ω–µ–≥!";
        }
        placingTower = null;
        // mouseGridPos = { x: -1, y: -1 }; // –ù–µ –Ω—É–∂–Ω–æ, mousemove –æ–±–Ω–æ–≤–∏—Ç
        setTimeout(() => gameStatusDisplay.textContent = (waveInProgress && !gameIsOver) ? `–í–æ–ª–Ω–∞ ${currentWave} –∏–¥–µ—Ç...` : "", 2000);
    }

    function gameOver() {
        if (gameIsOver) return;
        gameIsOver = true;
        waveInProgress = false;
        if (spawnIntervalId) clearInterval(spawnIntervalId);
        startWaveButton.disabled = true;
        gameStatusDisplay.textContent = `–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê! –í–æ–ª–Ω: ${currentWave > 0 ? currentWave : 0}.`;
        console.log("–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!");
    }

    // --- –ò–≥—Ä–æ–≤–æ–π —Ü–∏–∫–ª ---
    let lastTime = 0;
    function gameLoop(currentTime) {
        if (gameIsOver) {
            ctx.fillStyle = "rgba(40,40,40,0.85)";
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.font = "bold 48px Arial"; ctx.textAlign = "center";
            ctx.fillStyle = "white";
            ctx.fillText("–ò–ì–†–ê –û–ö–û–ù–ß–ï–ù–ê", canvas.width/2, canvas.height/2 - 50);
            ctx.font = "28px Arial";
            ctx.fillText(`–í—ã –ø—Ä–æ–¥–µ—Ä–∂–∞–ª–∏—Å—å: ${currentWave > 0 ? currentWave : 0} –≤–æ–ª–Ω`, canvas.width/2, canvas.height/2);
            ctx.font = "22px Arial";
            ctx.fillText(`–î–µ–Ω—å–≥–∏: ${money}`, canvas.width/2, canvas.height/2 + 40);
            ctx.font = "16px Arial";
            ctx.fillText("–û–±–Ω–æ–≤–∏—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É, —á—Ç–æ–±—ã –Ω–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ.", canvas.width/2, canvas.height/2 + 80);
            return;
        }

        const deltaTime = (currentTime - lastTime) / 1000; // –í —Å–µ–∫—É–Ω–¥–∞—Ö
        lastTime = currentTime;

        // 1. Update logic
        towers.forEach(tower => tower.update(currentTime, enemies));

        // –û–±–Ω–æ–≤–ª—è–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º —Å–Ω–∞—Ä—è–¥—ã
        projectiles = projectiles.filter(p => !p.update(enemies));

        // –û–±–Ω–æ–≤–ª—è–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –≤—Ä–∞–≥–æ–≤ (–∏—Å–ø–æ–ª—å–∑—É–µ–º –æ–±—Ä–∞—Ç–Ω—ã–π —Ü–∏–∫–ª –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —É–¥–∞–ª–µ–Ω–∏—è)
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (enemy.health <= 0) { // –ï—Å–ª–∏ –≤—Ä–∞–≥ —É–±–∏—Ç (–Ω–∞–ø—Ä–∏–º–µ—Ä, —Å–Ω–∞—Ä—è–¥–æ–º)
                visualEffects.push(new VisualEffect(enemy.x, enemy.y, enemy.width * 1.6, 'rgba(200,50,50,0.4)', 180, 'explosion'));
                enemies.splice(i, 1);
            } else if (enemy.update()) { // –ï—Å–ª–∏ enemy.update() –≤–µ—Ä–Ω—É–ª true (–¥–æ—Å—Ç–∏–≥ –±–∞–∑—ã)
                enemies.splice(i, 1);
            }
        }

        // –û–±–Ω–æ–≤–ª—è–µ–º –∏ —Ñ–∏–ª—å—Ç—Ä—É–µ–º –≤–∏–∑—É–∞–ª—å–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
        visualEffects = visualEffects.filter(effect => !effect.update());


        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ –≤–æ–ª–Ω—ã
        if (waveInProgress && spawnCounter >= waveEnemiesToSpawn && enemies.length === 0 && spawnIntervalId === null) {
            waveInProgress = false;
            startWaveButton.disabled = false;
            gameStatusDisplay.textContent = `–í–æ–ª–Ω–∞ ${currentWave} –∑–∞–≤–µ—Ä—à–µ–Ω–∞! –ì–æ—Ç–æ–≤—å—Ç–µ—Å—å –∫ —Å–ª–µ–¥—É—é—â–µ–π.`;
            money += 100 + currentWave * 10; // –ë–æ–Ω—É—Å –∑–∞ –≤–æ–ª–Ω—É
            updateUIDisplay();
        }

        // 2. Draw everything
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid();
        drawPath();
        towers.forEach(tower => tower.draw(ctx));
        enemies.forEach(enemy => enemy.draw(ctx));
        projectiles.forEach(projectile => projectile.draw(ctx));
        visualEffects.forEach(effect => effect.draw(ctx));


        // –û—Ç—Ä–∏—Å–æ–≤–∫–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –±–∞—à–Ω–∏
        if (placingTower && mouseGridPos.x !== -1) {
            const canPlace = towersPlacedCount < MAX_TOWERS &&
                             money >= placingTower.cost &&
                             isCellBuildable(mouseGridPos.x, mouseGridPos.y);

            ctx.globalAlpha = 0.6;
            let previewTowerColor = canPlace ? 'rgba(0, 200, 0, 0.4)' : 'rgba(200, 0, 0, 0.4)';
            ctx.fillStyle = previewTowerColor;
            ctx.fillRect(mouseGridPos.x - TILE_SIZE * 0.4, mouseGridPos.y - TILE_SIZE * 0.4, TILE_SIZE * 0.8, TILE_SIZE * 0.8);

            ctx.beginPath();
            ctx.arc(mouseGridPos.x, mouseGridPos.y, placingTower.range, 0, Math.PI * 2);
            ctx.strokeStyle = canPlace ? 'rgba(0, 255, 0, 0.5)' : 'rgba(255,0,0,0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
             if (placingTower.splashRadius > 0) {
                ctx.beginPath();
                ctx.arc(mouseGridPos.x, mouseGridPos.y, placingTower.splashRadius, 0, Math.PI * 2);
                ctx.strokeStyle = canPlace ? 'rgba(255, 165, 0, 0.5)' : 'rgba(100,70,0,0.5)';
                ctx.stroke();
            }
            ctx.lineWidth = 1;
            ctx.globalAlpha = 1.0;
        }

        requestAnimationFrame(gameLoop);
    }

    function upgradeTower() {
    if (!selectedTower || money < upgradeCost) {
        gameStatusDisplay.textContent = "–í—ã–±–µ—Ä–∏—Ç–µ –±–∞—à–Ω—é –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–µ–Ω–µ–≥!";
        setTimeout(() => gameStatusDisplay.textContent = "", 2000);
        return;
    }

    money -= upgradeCost;
    if (selectedTower.type === 'sniper') {
        selectedTower.projectileDamage *= 1.5;
    } else {
        selectedTower.projectileDamage *= 1.7;
    }
    upgradeCost *= 2; // –£–≤–µ–ª–∏—á–µ–Ω–∏–µ —Å—Ç–æ–∏–º–æ—Å—Ç–∏ —É–ª—É—á—à–µ–Ω–∏—è –≤ 2 —Ä–∞–∑–∞
    updateUIDisplay();
    gameStatusDisplay.textContent = `–ë–∞—à–Ω—è —É–ª—É—á—à–µ–Ω–∞! –ù–æ–≤—ã–π —É—Ä–æ–Ω: ${selectedTower.projectileDamage}`;
    setTimeout(() => gameStatusDisplay.textContent = "", 2000);
}


    // --- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è UI –∏ —Å–æ–±—ã—Ç–∏–π ---
    function init() {
    const uiPanel = document.querySelector('.ui-panel');
    if (uiPanel) {
        const towerSelectionDiv = document.getElementById('tower-selection');
        if (towerSelectionDiv) {
            uiPanel.insertBefore(towersPlacedDisplay, towerSelectionDiv);
        } else {
            uiPanel.appendChild(towersPlacedDisplay);
        }
    } else {
        document.body.appendChild(towersPlacedDisplay);
    }
    updateUIDisplay();

    startWaveButton.addEventListener('click', startNewWave);
    document.getElementById('upgradeTowerButton').addEventListener('click', upgradeTower);


    towerButtons.forEach(button => {
        button.addEventListener('click', () => {
            if (gameIsOver || waveInProgress && towersPlacedCount >= MAX_TOWERS) return;

            const type = button.dataset.type;
            const cost = parseInt(button.dataset.cost);

            if (towersPlacedCount >= MAX_TOWERS) {
                gameStatusDisplay.textContent = `–î–æ—Å—Ç–∏–≥–Ω—É—Ç –ª–∏–º–∏—Ç –±–∞—à–µ–Ω (${MAX_TOWERS})!`;
                setTimeout(() => gameStatusDisplay.textContent = "", 2000);
                return;
            }

            if (money >= cost) {
                let range = 0, splashRadius = 0;
                let towerName = "";
                switch (type) {
                    case 'basic': range = TILE_SIZE * 3.2; towerName = "–ü—Ä–æ—Å—Ç–∞—è"; break;
                    case 'sniper': range = TILE_SIZE * 6.0; towerName = "–°–Ω–∞–π–ø–µ—Ä"; break;
                    case 'splash': range = TILE_SIZE * 2.7; splashRadius = TILE_SIZE * 1.4; towerName = "–û–±–ª–∞—Å—Ç—å"; break;
                }
                placingTower = { type, cost, range, splashRadius };
                gameStatusDisplay.textContent = `–í—ã–±—Ä–∞–Ω–∞: ${towerName}. –†–∞–∑–º–µ—Å—Ç–∏—Ç–µ –Ω–∞ –ø–æ–ª–µ.`;
            } else {
                gameStatusDisplay.textContent = `–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–µ–Ω–µ–≥!`;
                setTimeout(() => gameStatusDisplay.textContent = "", 2000);
            }
        });
    });

    canvas.addEventListener('click', (event) => {
        const rect = canvas.getBoundingClientRect();
        const x = event.clientX - rect.left;
        const y = event.clientY - rect.top;
        const gridX = Math.floor(x / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;
        const gridY = Math.floor(y / TILE_SIZE) * TILE_SIZE + TILE_SIZE / 2;

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–ª—É—á—à–µ–Ω–∏–µ –±–∞—à–µ–Ω
        for (const tower of towers) {
            const distSq = (gridX - tower.x) * (gridX - tower.x) + (gridY - tower.y) * (gridY - tower.y);
            if (distSq < (TILE_SIZE * 0.5) * (TILE_SIZE * 0.5)) {
                selectedTower = tower;
                document.getElementById('upgradeTowerButton').disabled = false;
                gameStatusDisplay.textContent = `–í—ã–±—Ä–∞–Ω–∞ –±–∞—à–Ω—è –¥–ª—è —É–ª—É—á—à–µ–Ω–∏—è!`;
                setTimeout(() => gameStatusDisplay.textContent = "", 2000);
                return;
            }
        }

        handleTowerPlacement(event);
    });


    canvas.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        if (placingTower) {
            placingTower = null;
            gameStatusDisplay.textContent = "–í—ã–±–æ—Ä –±–∞—à–Ω–∏ –æ—Ç–º–µ–Ω–µ–Ω.";
            setTimeout(() => gameStatusDisplay.textContent = "", 2000);
        }
    });

        requestAnimationFrame(gameLoop); // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
    }

    init(); // –í—ã–∑–æ–≤ —Ñ—É–Ω–∫—Ü–∏–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏
});

</script>
</html>